---
title: "02_pre_processing.Rmd"
author: "Leeya Pressburger"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    fig_caption: yes
    number_sections: yes
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## R setup

```{r intro, warning=FALSE, message=FALSE}
# Load necessary packages, read in workflow settings
library(hector)
library(tidyr)
library(ggplot2)
library(bookdown)
library(data.table) 
library(dplyr)
library(readr)

theme_set(theme_light())

source("common_data.R")

# Read in data files, generated by 01_generate_data.Rmd
runlist <- fread("../output/runlist.csv")
model_output <- fread("../output/model_output.csv")

# Add SSP information to the output data
model_output$ssp <- runlist$ssp[model_output$run_number]

# Read historical NOAA data for comparison graphs
# Comparing outputs to NOAA CO2 data from Mauna Loa observatory
# https://gml.noaa.gov/ccgg/trends/data.html
noaa <- read.csv("../input/noaa_co2_data.csv")
noaa_co2 <- noaa %>% 
  mutate(source = "NOAA") %>%
  filter(year < 2015)

# Define constants
HISTORICAL_CO2_YEARS <- 1959:2014
MAX_FAILFRAC_HISTORICAL <- 0.33
MAX_FAILFRAC_FUTURE <- 0.5

# Helper function to calculate out-of-bounds values and then run failures
# Handles either by SSP or not, which is a pain
run_failures <- function(filter_name, x, var_name, var_years, 
                         var_min_values, var_max_values, 
                         var_ssp, max_out_frac) {
  # Create an observational data frame
  if(is.null(var_ssp)) {
    y <- tibble(year = var_years, min_value = var_min_values, max_value = var_max_values)
    join_vars <- "year"
  } else {
    y <- tibble(year = var_years, ssp = var_ssp, 
                min_value = var_min_values, max_value = var_max_values)
    join_vars <- c("ssp", "year")
  }
  # Isolate the matching Hector data, merge with observations, calculate outs 
  # and the run failures (fraction of outs exceeds some limit)
  x %>% 
    filter(variable == var_name, year %in% unique(var_years)) %>% 
    left_join(y, by = join_vars) %>% 
    mutate(out = value < min_value | value > max_value) %>% 
    group_by(ssp, run_number) %>% 
    summarize(fraction_out = sum(out) / n(), .groups = "drop") %>% 
    mutate(fail = fraction_out > max_out_frac,
           filter = filter_name) 
}

# Helper function to plot a random subset of run, colored by fraction_out,
# with the filter bounds
run_fail_plot <- function(x, fail_data, n_sample, var_name, 
                          var_years, var_min_values, var_max_values, var_ssp) {
  # Create an observational data frame
  y <- tibble(year = var_years, min_value = var_min_values,
              max_value = var_max_values, ssp = var_ssp)
  if(is.null(var_ssp)) {
    join_vars <- "run_number"
  } else {
    join_vars <- c("ssp", "run_number")
  }
  # Plot a random slice of run data, colored by failure, and the CMIP6 bounds
  x %>% 
    distinct(run_number) %>% 
    slice_sample(n = n_sample, replace = TRUE) %>% 
    left_join(model_output, by = "run_number") %>%
    filter(variable == var_name, year %in% var_years) %>% 
    left_join(fail_data, by = join_vars) %>% 
    ggplot(aes(year, value)) +
    geom_line(aes(group = run_number, color = fraction_out)) +
    geom_point(data = y, aes(y = min_value)) +
    geom_point(data = y, aes(y = max_value)) +
    geom_line(data = y, aes(y = min_value)) +
    geom_line(data = y, aes(y = max_value)) +
    scale_color_distiller(palette = "BrBG") +
    ylab(var_name) +
    labs(color = "fraction of run failing") +
    ggtitle(paste("Filter:", fail_data$filter[1])) ->
    p
  
  if(!is.null(var_ssp)) p <- p + facet_wrap(~ssp)
  p
}
```

## Hector atmospheric CO~2~ vs observed data

``` {r ca-comp, echo = FALSE, fig.cap = " Historical CO2 data from Hector runs and CMIP6 data."}
# Compare CMIP6 historical CO2 concentration data with our model results

# First, read in CMIP CO2 data, compute summary statistics
cmip_co2_data <- read.csv("../input/CMIP6_annual_co2.csv")

# Isolate historical data
cmip_co2_hist <- cmip_co2_data %>%
  filter(year %in% HISTORICAL_CO2_YEARS,
         experiment == "historical",
         # Remove models with constant historical CO2
         !(model %in% c("NorESM2-MM", "NorESM2-LM"))) %>%
  mutate(value = value * 1e6,
         units = "ppm") %>%
  group_by(year, model) %>%
  mutate(value = mean(value)) %>%
  group_by(year) %>%
  summarize(sdev = sd(value), 
            med = median(value),
            source = "CMIP6",
            .groups = "drop")

# Isolate desired scenarios
cmip_co2_sce <- list()
for(n in names(SSP_files)){
  cmip_co2_sce[[n]] <- cmip_co2_data %>% 
    filter(experiment == n)
}  

cmip_co2_scenarios <- bind_rows(cmip_co2_sce)
rm(cmip_co2_data)

# Calculate summary metrics
cmip_c_scenarios <- cmip_co2_scenarios %>%
  rename(ssp = experiment) %>%
  filter(year <= 2100) %>%
  # convert to ppm
  mutate(value = value * 1e6) %>%
  group_by(year, ssp) %>%
  summarize(sdev = sd(value),
            minimum = min(value),
            maximum = max(value),
            med = median(value)) %>%
  mutate(source = "CMIP6")

# Create bounds using historical data and the standard deviation of the CMIP6 models
cmip_bounds_co2_hist <- cmip_co2_hist %>%
  select(year, sdev, med) %>%
  mutate(hist_mean = noaa_co2$mean,
         minimum = hist_mean - sdev,
         maximum = hist_mean + sdev,
         source = "CMIP6")

# Summarize
fails_co2_hist <- run_failures("CMIP6 historical CO2",
                               model_output,
                               "CO2_concentration", 
                               cmip_bounds_co2_hist$year, 
                               cmip_bounds_co2_hist$minimum, 
                               cmip_bounds_co2_hist$maximum, 
                               var_ssp = NULL,
                               max_out_frac = MAX_FAILFRAC_HISTORICAL)

co2_hist_plot <- run_fail_plot(model_output, fails_co2_hist, 125, "CO2_concentration",
              cmip_bounds_co2_hist$year, cmip_bounds_co2_hist$minimum, cmip_bounds_co2_hist$maximum, 
              var_ssp = NULL) +
  ylab("ppm")

ggsave(plot = co2_hist_plot, filename = "../figures/hist_co2_fails.png", height = 6, width = 9, units = "in")

```


## Hector temperature vs. CMIP6 

``` {r filtered, warning = FALSE, message = FALSE, echo = FALSE, fig.cap = "Global temperature anomaly from CMIP6 and filtered Hector runs. Lines show median; shaded areas show ±1 s.d. of median (darker) and minimum and maximum of ensemble (lighter)."}

# Read in CMIP6 comparison data
cmip_raw <- read.csv("../input/CMIP6_annual_tas_global.csv")

# Isolate historical data
cmip_tgav_hist <- cmip_raw %>% 
  filter(experiment == "historical",
         variable == "Tgav",
         year <= 2100) %>%
  group_by(year) %>%
  summarize(sdev = sd(value),
            minimum = min(value),
            maximum = max(value),
            med = median(value),
            .groups = "drop") %>%
  mutate(source = "CMIP6") 

# Isolate desired scenarios
cmip_tgav_sce <- list()
for(n in names(SSP_files)){
  cmip_tgav_sce[[n]] <- cmip_raw %>% 
    filter(experiment == n)
}  

cmip_sce <- bind_rows(cmip_tgav_sce)
rm(cmip_raw)

# Filter for Tgav and calculate summary metrics
cmip_t_scenarios <- cmip_sce %>%
  rename(ssp = experiment) %>%
  filter(variable == "Tgav",
         year <= 2100) %>%
  group_by(year, ssp) %>%
  summarize(sdev = sd(value),
            minimum = min(value),
            maximum = max(value),
            med = median(value)) %>%
  mutate(source = "CMIP6")

# Need to append the historical values to each SSP
# Add SSP column to historical data, repeat for all scenarios
cmip_hist_repeat_t <- list()
for(n in names(SSP_files)){
  cmip_hist_repeat_t[[n]] <- cmip_tgav_hist %>% 
    mutate(ssp = n)
}
cmip_hist_repeat <- bind_rows(cmip_hist_repeat_t)

cmip_t_final <- bind_rows(cmip_hist_repeat, cmip_t_scenarios)

# Create bounds
cmip_bounds_t <- select(cmip_t_final, ssp, year, minimum, maximum)

# Separate into historical and future
cmip_t_hist <- filter(cmip_t_final, year <= 2014)
cmip_t_future <- filter(cmip_t_final, year > 2014)

fails_cmip6tas_hist <- run_failures("CMIP6 historical TAS",
                                    model_output,
                                    "global_tas",
                                    cmip_t_hist$year,
                                    cmip_t_hist$minimum,
                                    cmip_t_hist$maximum,
                                    var_ssp = cmip_t_hist$ssp,
                                    max_out_frac = MAX_FAILFRAC_HISTORICAL)

hist_tas_fails <- run_fail_plot(model_output, fails_cmip6tas_hist, 125, "global_tas",
              cmip_t_hist$year,
              cmip_t_hist$minimum,
              cmip_t_hist$maximum,
              var_ssp = NULL) +
  ylab("°C")

ggsave(plot = hist_tas_fails, filename = "../figures/hist_tas_fails.png", height = 6, width  = 9, units = "in")

fails_cmip6tas_future <- run_failures("CMIP6 future TAS",
                                      model_output, 
                                      "global_tas",
                                      cmip_t_future$year,
                                      cmip_t_future$minimum,
                                      cmip_t_future$maximum,
                                      var_ssp = cmip_t_future$ssp,
                                      max_out_frac = MAX_FAILFRAC_FUTURE)

future_tas_fails <- run_fail_plot(model_output, fails_cmip6tas_future, 125, "global_tas",
              cmip_t_future$year,
              cmip_t_future$minimum,
              cmip_t_future$maximum,
              var_ssp = cmip_t_future$ssp) +
  ylab("°C")


ggsave(plot = future_tas_fails, filename = "../figures/future_tas_fails.png", height = 6, width  = 9, units = "in")
```

## Land and ocean C sinks 

```{r}
# Standard deviation multiplier for the land sink. We do this because:
# 1. The GCP models are driven by 'perfect' (observational) climate; it's
#    not reasonable for an annual model like Hector to replicate this
# 2. The land sink mean is the model mean, not an observation.
GCP_SD_X <- 3
# Read comparison data from Global Carbon Project 2022
readr::read_csv("../input/gcp_land_ocean_sinks.csv", skip = 1) %>% 
  mutate(land_sink_low = land_sink_mean - GCP_SD_X * land_sink_sd,
         land_sink_high = land_sink_mean + GCP_SD_X * land_sink_sd,
         ocean_sink_low = ocean_sink_mean - GCP_SD_X * ocean_sink_sd,
         ocean_sink_high = ocean_sink_mean + GCP_SD_X * ocean_sink_sd) ->
  sinks

fails_landsink <- run_failures("GCP land sink",
                               model_output, 
                               "NBP",
                               sinks$Year,
                               sinks$land_sink_low,
                               sinks$land_sink_high,
                               var_ssp = NULL,
                               max_out_frac = MAX_FAILFRAC_HISTORICAL)

landsink_fails <- run_fail_plot(model_output, fails_landsink, 125, "NBP",
                   sinks$Year,
                   sinks$land_sink_low,
                   sinks$land_sink_high,
                   var_ssp = NULL) +
  ylab(expression(CO[2]~flux~~(Gt~yr^-1)))


fails_oceansink <- run_failures("GCP ocean sink",
                                model_output, 
                                "ocean_uptake",
                                sinks$Year,
                                sinks$ocean_sink_low,
                                sinks$ocean_sink_high,
                                var_ssp = NULL,
                                max_out_frac = MAX_FAILFRAC_HISTORICAL)

oceansink_fails <- run_fail_plot(model_output, fails_oceansink, 125, "ocean_uptake",
              sinks$Year,
              sinks$ocean_sink_low,
              sinks$ocean_sink_high,
              var_ssp = NULL) +
  ylab(expression(CO[2]~flux~~(Gt~yr^-1)))

ggsave(plot = landsink_fails, filename = "../figures/landsink_fails.png", height = 6, width  = 9, units = "in")
ggsave(plot = oceansink_fails, filename = "../figures/oceansink_fails.png", height = 6, width  = 9, units = "in")
```


## Summary of run filtering

```{r, run-filtering}
# Filter model output data
n_runs <- length(unique(model_output$run_number))
fail_summary <- bind_rows(fails_co2_hist, 
                          fails_cmip6tas_hist, fails_cmip6tas_future,
                          fails_landsink, fails_oceansink)

fail_summary %>% 
  group_by(run_number) %>% 
  # runs have to pass ALL the filters
  summarise(all_pass = all(!fail), .groups = "drop") %>% 
  filter(all_pass) %>% 
  select(run_number) %>% 
  left_join(model_output, by = "run_number") ->
  model_output_final
n_runs_final <- length(unique(model_output_final$run_number))

# Remove large data
rm(model_output)
gc()
```

Before filtering there were `r n_runs` runs.

After filtering there are `r n_runs_final` runs.

Run failure rates by filtering step:

```{r}
fail_summary_out <- fail_summary %>% 
  group_by(filter, fail) %>% 
  summarise(n = n(), .groups = "drop") %>%
  pivot_wider(names_from = fail, values_from = n, names_prefix = "fail_", values_fill = 0) %>%
  mutate(fail_percent = round(fail_TRUE / (fail_TRUE + fail_FALSE) * 100, 1))

fail_summary_out %>% 
  knitr::kable()

# Write output file
write.csv("../output/fail_summary_filter.csv")

```

Top 10 worst-performing runs:

```{r}
fail_summary %>% 
  group_by(ssp, run_number) %>% 
  summarise(fails = sum(fail), .groups = "drop") %>% 
  #arrange(desc(fails)) %>% 
  head(n = 10) %>% 
  knitr::kable()
```


## Plot metrics

```{r plots}
# Figure 1
plot_out <- gridExtra::grid.arrange(landsink_fails, oceansink_fails, hist_tas_fails, future_tas_fails, co2_hist_plot)

ggsave(plot = plot_out, filename = "../figures/figure1.png", height = 8, width = 10, units = "in")

```


## Write out and wrap up

``` {r cleanup-cmip, echo = FALSE}
# Write out model output data, clean environment
fwrite(model_output_final, "../output/model_output_final.csv", row.names = FALSE)
final_runs <- unique(model_output_final$run_number)

# Filter and write out tracking data
trk_output <- fread("../output/trk_output.csv")
trk_output$ssp <- runlist$ssp[trk_output$run_number]
trk_output_final <- filter(trk_output, run_number %in% final_runs)

# Remove large data and force clear memory
rm(trk_output)
gc()
fwrite(trk_output_final, "../output/trk_output_final.csv", row.names = FALSE)

sessionInfo()
```

