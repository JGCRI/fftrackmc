---
title: "02_pre_processing.Rmd"
author: "Leeya Pressburger"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    fig_caption: yes
    number_sections: yes
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## R setup

```{r intro, warning=FALSE, message=FALSE}
library(hector)
library(tidyr)
library(ggplot2)
library(bookdown)
library(data.table) 
library(dplyr)
library(readr)

theme_set(theme_light())

source("common_data.R")

# Read in data files, generated by 01_generate_data.Rmd
runlist <- fread("../output/runlist.csv")
model_output <- fread("../output/model_output.csv")
trk_output <- fread("../output/trk_output.csv")

# Add ssp information to the output data
model_output$ssp <- runlist$ssp[model_output$run_number]
trk_output$ssp <- runlist$ssp[trk_output$run_number]

# Read historical NOAA data for comparison graphs
# Comparing outputs to NOAA CO2 data from Mauna Loa observatory
# https://gml.noaa.gov/ccgg/trends/data.html
noaa <- read.csv("../input/noaa_co2_data.csv")
noaa_co2 <- noaa %>% 
  mutate(source = "NOAA") %>%
  filter(year < 2015)

# Define constants
HISTORICAL_CO2_YEARS <- 1959:2014
MAX_FAILFRAC_HISTORICAL <- 0.33
MAX_FAILFRAC_FUTURE <- 0.5

# Helper function to calculate out-of-bounds values and then run failures
# Handles either by SSP or not, which is a pain
run_failures <- function(filter_name, x, var_name, var_years, 
                         var_min_values, var_max_values, 
                         var_ssp, max_out_frac) {
  # Create an observational data frame
  if(is.null(var_ssp)) {
    y <- tibble(year = var_years, min_value = var_min_values, max_value = var_max_values)
    join_vars <- "year"
  } else {
    y <- tibble(year = var_years, ssp = var_ssp, 
              min_value = var_min_values, max_value = var_max_values)
    join_vars <- c("ssp", "year")
  }
  # Isolate the matching Hector data, merge with observations, calculate outs 
  # and the run failures (fraction of outs exceeds some limit)
  x %>% 
    filter(variable == var_name, year %in% unique(var_years)) %>% 
    left_join(y, by = join_vars) %>% 
    mutate(out = value < min_value | value > max_value) %>% 
    group_by(ssp, run_number) %>% 
    summarize(fraction_out = sum(out) / n(), .groups = "drop") %>% 
    mutate(fail = fraction_out > max_out_frac,
           filter = filter_name) 
}

# Helper function to plot a random subset of run, colored by fraction_out,
# with the filter bounds
run_fail_plot <- function(x, fail_data, n_sample, var_name, 
                          var_years, var_min_values, var_max_values, var_ssp) {
  # Create an observational data frame
  y <- tibble(year = var_years, min_value = var_min_values,
              max_value = var_max_values, ssp = var_ssp)
  if(is.null(var_ssp)) {
    join_vars <- "run_number"
  } else {
    join_vars <- c("ssp", "run_number")
  }
  # Plot a random slice of run data, colored by failure, and the CMIP6 bounds
  x %>% 
    distinct(run_number) %>% 
    slice_sample(n = n_sample, replace = TRUE) %>% 
    left_join(model_output, by = "run_number") %>%
    filter(variable == var_name, year %in% var_years) %>% 
    left_join(fail_data, by = join_vars) %>% 
    ggplot(aes(year, value)) +
    geom_line(aes(group = run_number, color = fraction_out)) +
    geom_point(data = y, aes(y = min_value)) +
    geom_point(data = y, aes(y = max_value)) +
    geom_line(data = y, aes(y = min_value)) +
    geom_line(data = y, aes(y = max_value)) +
    # Mauna Loa historical data for comparison
    #  geom_line(data = noaa_co2, aes(y = mean), color = "red", size = 2) +
    scale_color_distiller(palette = "BrBG") +
    ylab(var_name) +
    ggtitle(paste("Filter:", fail_data$filter[1])) ->
    p
  
  if(!is.null(var_ssp)) p <- p + facet_wrap(~ssp)
  p
}
```

## Hector atmospheric CO~2~ vs observed data

``` {r ca-comp, echo = FALSE, fig.cap = " Historical CO2 data from Hector runs and CMIP6 data."}
# This chunk will compare CMIP6 historical CO2 concentration data with 
# Hector data generated by our model runs

# First, we need to read in the CMIP6 data and organize
# Read in CMIP CO2 data, compute summary statistics
cmip_co2_data <- read.csv("../input/CMIP6_annual_co2.csv")

# Isolate historical data
cmip_co2_hist <- cmip_co2_data %>%
  filter(year %in% HISTORICAL_CO2_YEARS,
         experiment == "historical",
         # Remove models with constant historical CO2
         !(model %in% c("NorESM2-MM", "NorESM2-LM"))) %>%
  mutate(value = value * 1e6,
         units = "ppm") %>%
  group_by(year, model) %>%
  mutate(value = mean(value)) %>%
  group_by(year) %>%
  summarize(sdev = sd(value), 
            med = median(value),
            source = "CMIP6",
            .groups = "drop")

# Isolate desired scenarios
cmip_co2_sce <- list()
for(n in names(SSP_files)){
  cmip_co2_sce[[n]] <- cmip_co2_data %>% 
    filter(experiment == n)
}  

cmip_co2_scenarios <- bind_rows(cmip_co2_sce)
rm(cmip_co2_data)

# Calculate summary metrics
cmip_c_scenarios <- cmip_co2_scenarios %>%
  rename(ssp = experiment) %>%
  filter(year <= 2100) %>%
  # convert to ppm
  mutate(value = value * 1e6) %>%
  group_by(year, ssp) %>%
  summarize(sdev = sd(value),
            minimum = min(value),
            maximum = max(value),
            med = median(value)) %>%
  mutate(source = "CMIP6") %>%
  arrange(ssp, year)


# Create bounds using historical data and the standard deviation of the CMIP6 models
cmip_bounds_co2_hist <- cmip_co2_hist %>%
  select(year, sdev, med) %>%
  mutate(hist_mean = noaa_co2$mean,
         minimum = hist_mean - sdev,
         maximum = hist_mean + sdev,
         source = "CMIP6")

# Summarize
fails_co2_hist <- run_failures("CMIP6 historical CO2",
                          model_output,
                          "CO2_concentration", 
                          cmip_bounds_co2_hist$year, 
                          cmip_bounds_co2_hist$minimum, 
                          cmip_bounds_co2_hist$maximum, 
                          var_ssp = NULL,
                          max_out_frac = MAX_FAILFRAC_HISTORICAL)

run_fail_plot(model_output, fails_co2_hist, 100, "CO2_concentration",
              cmip_bounds_co2_hist$year, cmip_bounds_co2_hist$minimum, cmip_bounds_co2_hist$maximum, 
              var_ssp = NULL)

# # Future
# fails_co2_future <- run_failures("CMIP6 future CO2",
#                                       model_output, 
#                                       "CO2_concentration",
#                                       cmip_c_scenarios$year,
#                                       cmip_c_scenarios$minimum,
#                                       cmip_c_scenarios$maximum,
#                                       var_ssp = cmip_c_scenarios$ssp,
#                                       max_out_frac = MAX_FAILFRAC_FUTURE)
# 
# run_fail_plot(model_output, fails_co2_future, 100, "CO2_concentration",
#               cmip_c_scenarios$year,
#               cmip_c_scenarios$minimum,
#               cmip_c_scenarios$maximum,
#               var_ssp = cmip_c_scenarios$ssp)

## Plot
# Read in filtered Hector data, compute summary statistics 
# hector_co2_summary <- model_output_filtered_1 %>%
#   filter(variable == "CO2_concentration",
#          year %in% HISTORICAL_CO2_YEARS,
#          ssp == MAIN_SCENARIO) %>%
#   select(run_number, year, value) %>%
#   group_by(year) %>%
#   summarize(sdev = sd(value), 
#             minimum = min(value),
#             maximum = max(value),
#             med = median(value),
#             source = "Hector",
#             .groups = "drop")

# Combine data
# plot_data_co2 <- bind_rows(cmip_bounds_h, hector_co2_summary)

# Plot
# co2_plot <- plot_data_co2 %>% 
#   filter(year < 2015) %>%
#   ggplot(aes(year, fill = source, color = source)) +
#   geom_ribbon(aes(ymin = minimum, ymax = maximum), alpha = 0.15, color = NA) +
#   geom_ribbon(aes(ymin = med - sdev, ymax = med + sdev), alpha = 0.5, color = NA) +
#   geom_line(aes(y = med), size = 2) +
#   geom_line(data = noaa_co2, aes(year, mean), size = 2) +
#   scale_color_manual(breaks = c("CMIP6", "Hector", "NOAA"),
#                      values = c("#dfc27d", "#01665e", "#bf812d")) +
#   scale_fill_manual(breaks = c("CMIP6", "Hector", "NOAA"),
#                     values = c("#dfc27d", "#01665e", "#bf812d")) +
#   labs(x = "Year",
#        y = expression(Atmospheric~CO[2]~(ppm)),
#        color = "Source",
#        fill = "Source") +
#   scale_x_continuous(expand = c(0, 0)) # co2_plot

#ggsave(plot = co2_plot, "../figures/figure1.png", height = 6, width = 9, units = "in")

```


## Hector temperature vs. CMIP6 

``` {r filtered, warning = FALSE, message = FALSE, echo = FALSE, fig.cap = "Global temperature anomaly from CMIP6 and filtered Hector runs. Lines show median; shaded areas show Â±1 s.d. of median (darker) and minimum and maximum of ensemble (lighter)."}

# Read in CMIP6 comparison data
cmip_raw <- read.csv("../input/CMIP6_annual_tas_global.csv")

# Isolate historical data
cmip_tgav_hist <- cmip_raw %>% 
  filter(experiment == "historical",
         variable == "Tgav",
         year <= 2100) %>%
  group_by(year) %>%
  summarize(sdev = sd(value),
            minimum = min(value),
            maximum = max(value),
            med = median(value),
            .groups = "drop") %>%
  mutate(source = "CMIP6") 

# Isolate desired scenarios
cmip_tgav_sce <- list()
for(n in names(SSP_files)){
  cmip_tgav_sce[[n]] <- cmip_raw %>% 
    filter(experiment == n)
}  

cmip_sce <- bind_rows(cmip_tgav_sce)
rm(cmip_raw)

# Filter for Tgav and calculate summary metrics
cmip_t_scenarios <- cmip_sce %>%
  rename(ssp = experiment) %>%
  filter(variable == "Tgav",
         year <= 2100) %>%
  group_by(year, ssp) %>%
  summarize(sdev = sd(value),
            minimum = min(value),
            maximum = max(value),
            med = median(value)) %>%
  mutate(source = "CMIP6") %>%
  arrange(ssp, year)

# Need to append the historical values to each SSP
# Add SSP column to historical data, repeat for all scenarios
cmip_hist_repeat_t <- list()
for(n in names(SSP_files)){
  cmip_hist_repeat_t[[n]] <- cmip_tgav_hist %>% 
    mutate(ssp = n)
}
cmip_hist_repeat <- bind_rows(cmip_hist_repeat_t)

cmip_t_final <- bind_rows(cmip_hist_repeat, cmip_t_scenarios) %>% 
  arrange(ssp, year)

### Now that we have all the data we'll need in one place, we want to filter out 
# run numbers twice.
# First, we just want to look at the historical data. Then we'll look at each SSP

cmip_bounds_t <- select(cmip_t_final, ssp, year, minimum, maximum)

cmip_t_hist <- filter(cmip_t_final, year <= 2014)
cmip_t_future <- filter(cmip_t_final, year > 2014)

fails_cmip6tas_hist <- run_failures("CMIP6 historical TAS",
                                    model_output,
                                    "global_tas",
                                    cmip_t_hist$year,
                                    cmip_t_hist$minimum,
                                    cmip_t_hist$maximum,
                                    var_ssp = cmip_t_hist$ssp,
                                    max_out_frac = MAX_FAILFRAC_HISTORICAL)

run_fail_plot(model_output, fails_cmip6tas_hist, 100, "global_tas",
              cmip_t_hist$year,
              cmip_t_hist$minimum,
              cmip_t_hist$maximum,
              var_ssp = NULL)

fails_cmip6tas_future <- run_failures("CMIP6 future TAS",
                                      model_output, 
                                      "global_tas",
                                      cmip_t_future$year,
                                      cmip_t_future$minimum,
                                      cmip_t_future$maximum,
                                      var_ssp = cmip_t_future$ssp,
                                      max_out_frac = MAX_FAILFRAC_FUTURE)

run_fail_plot(model_output, fails_cmip6tas_future, 100, "global_tas",
              cmip_t_future$year,
              cmip_t_future$minimum,
              cmip_t_future$maximum,
              var_ssp = cmip_t_future$ssp)
```

## Land and ocean C sinks 

```{r}
# Standard deviation multiplier for the land sink. We do this because:
# 1. The GCP models are driven by 'perfect' (observational) climate; it's
#    not reasonable for an annual model like Hector to replicate this
# 2. The land sink mean is the model mean, not an observation.
GCP_SD_X <- 3
# Read comparison data from Global Carbon Project 2022
readr::read_csv("../input/gcp_land_ocean_sinks.csv", skip = 1) %>% 
  mutate(land_sink_low = land_sink_mean - GCP_SD_X * land_sink_sd,
         land_sink_high = land_sink_mean + GCP_SD_X * land_sink_sd,
         ocean_sink_low = ocean_sink_mean - GCP_SD_X * ocean_sink_sd,
         ocean_sink_high = ocean_sink_mean + GCP_SD_X * ocean_sink_sd) ->
  sinks

fails_landsink <- run_failures("GCP land sink",
                               model_output, 
                               "NBP",
                               sinks$Year,
                               sinks$land_sink_low,
                               sinks$land_sink_high,
                               var_ssp = NULL,
                               max_out_frac = MAX_FAILFRAC_HISTORICAL)

p <- run_fail_plot(model_output, fails_landsink, 100, "NBP",
              sinks$Year,
              sinks$land_sink_low,
              sinks$land_sink_high,
              var_ssp = NULL)


fails_oceansink <- run_failures("GCP ocean sink",
                               model_output, 
                               "NBP",
                               sinks$Year,
                               sinks$ocean_sink_low,
                               sinks$ocean_sink_high,
                               var_ssp = NULL,
                               max_out_frac = MAX_FAILFRAC_HISTORICAL)

run_fail_plot(model_output, fails_oceansink, 100, "NBP",
              sinks$Year,
              sinks$ocean_sink_low,
              sinks$ocean_sink_high,
              var_ssp = NULL)

print(p + ggtitle(paste(p$labels$title, "with GCP_SD_X =", GCP_SD_X)))
```


## Summary of run filtering

```{r, run-filtering}
# Filter model output data
n_runs <- length(unique(model_output$run_number))
fail_summary <- bind_rows(fails_co2_hist, 
                          fails_cmip6tas_hist, fails_cmip6tas_future,
                          fails_landsink, fails_oceansink)

fail_summary %>% 
  group_by(run_number) %>% 
  # runs have to pass ALL the filters
  summarise(all_pass = all(!fail), .groups = "drop") %>% 
  filter(all_pass) %>% 
  select(run_number) %>% 
  left_join(model_output, by = "run_number") ->
  model_output_final
n_runs_final <- length(unique(model_output_final$run_number))

# Remove large data
rm(model_output)
```

Before filtering there were `r n_runs` runs.

After filtering there are `r n_runs_final` runs.

Run failure rates by filtering step:

```{r}
fail_summary %>% 
  group_by(filter, fail) %>% 
  summarise(n = n(), .groups = "drop") %>%
  pivot_wider(names_from = fail, values_from = n, names_prefix = "fail_", values_fill = 0) %>%
  mutate(fail_percent = round(fail_TRUE / (fail_TRUE + fail_FALSE) * 100, 1)) %>% 
  knitr::kable()
```

Top 10 worst-performing runs:

```{r}
fail_summary %>% 
  group_by(ssp, run_number) %>% 
  summarise(fails = sum(fail), .groups = "drop") %>% 
  arrange(desc(fails)) %>% 
  head(n = 10) %>% 
  knitr::kable()
```

## Filter tracking data

``` {r filter-tracking}
# Note that the tracking output needs to be filtered as well
trk_output_final <- filter(trk_output, run_number %in% unique(model_output_final$run_number))

# Remove large data and force clear memory
rm(trk_output)
gc()
```

## Write out and wrap up

``` {r cleanup-cmip, echo = FALSE}
# Write out data, clean environment
fwrite(model_output_final, "../output/model_output_final.csv", row.names = FALSE)
fwrite(trk_output_final, "../output/trk_output_final.csv", row.names = FALSE)

sessionInfo()
```

